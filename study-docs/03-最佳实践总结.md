# WildVoice 项目最佳实践总结

## 🎯 目的
总结在开发 WildVoice 过程中学到的最佳实践，作为未来项目的参考。

---

## 一、项目架构设计

### 1.1 模块化组织

✅ **DO - 推荐做法**:
```
src/
├── app/              # Next.js App Router
│   ├── api/         # API Routes
│   └── (pages)/     # 页面
├── modules/         # 功能模块
│   ├── voices/
│   │   └── schemas/
│   ├── outputs/
│   │   └── schemas/
│   └── auth/
│       └── schemas/
├── lib/             # 共享工具函数
├── components/      # 共享组件
└── db/              # 数据库配置
```

**优势**:
- 功能内聚，易于维护
- 团队协作时减少冲突
- 代码复用性高

❌ **DON'T - 避免做法**:
```
src/
├── schemas/         # 所有 schema 混在一起
├── apis/            # 所有 API 混在一起
└── utils/           # 所有工具函数混在一起
```

---

### 1.2 统一的响应格式

✅ **DO**:
```typescript
// 创建统一的响应接口
export interface ApiResponse<T = any> {
    success: boolean;
    data: T | null;
    error: string | null;
    message?: string;
}

// 所有 API 使用相同格式
return successResponse({ id: 1, name: "Voice" }, "Created successfully", 201);
```

**优势**:
- 前端处理逻辑统一
- 易于调试
- 类型安全

❌ **DON'T**:
```typescript
// API 1
return { data: {...} };

// API 2
return { success: true, result: {...} };

// API 3
return {...};  // 直接返回数据
```

---

## 二、数据库设计

### 2.1 Schema 定义规范

✅ **DO**:
```typescript
export const voicesSchema = sqliteTable("voices", {
    // 1. 主键在最前
    id: integer("id").primaryKey({ autoIncrement: true }),

    // 2. 必填字段
    name: text("name").notNull(),
    userId: text("user_id")
        .notNull()
        .references(() => user.id, { onDelete: "cascade" }),

    // 3. 可选字段
    category: text("category"),
    description: text("description"),

    // 4. 时间戳在最后
    createdAt: integer("created_at", { mode: "timestamp" })
        .defaultNow()
        .notNull(),
    updatedAt: integer("updated_at", { mode: "timestamp" })
        .$onUpdate(() => new Date())
        .notNull(),
});
```

**优势**:
- 字段顺序清晰
- 易于阅读和维护

---

### 2.2 外键约束

✅ **DO**:
```typescript
userId: text("user_id")
    .references(() => user.id, {
        onDelete: "cascade",  // 明确删除行为
        onUpdate: "no action"
    }),
```

**常见的 onDelete 策略**:
- `cascade` - 级联删除（删除用户时删除其所有 voices）
- `set null` - 设置为 null（删除用户时 voice 保留但 userId 为 null）
- `restrict` - 禁止删除（有关联记录时不允许删除用户）
- `no action` - 不采取行动

**选择标准**:
- 强依赖关系 → `cascade`
- 弱依赖关系 → `set null`
- 重要数据保护 → `restrict`

---

### 2.3 Zod 验证最佳实践

✅ **DO**:
```typescript
export const insertVoiceSchema = createInsertSchema(voicesSchema, {
    // 添加自定义验证规则
    name: z.string().min(1, "名称不能为空").max(100, "名称过长"),
    rating: z.number().min(0, "最小为0").max(5, "最大为5").optional(),

    // 更严格的 URL 验证
    sampleAudioUrl: z
        .string()
        .url("无效的 URL")
        .optional()
        .or(z.literal("")),  // 允许空字符串
});

// 更新时的 schema 应该排除不可修改字段
export const updateVoiceSchema = insertVoiceSchema.partial().omit({
    id: true,
    userId: true,
    createdAt: true,
});
```

**优势**:
- 清晰的错误提示
- 防止数据污染
- 更安全

---

## 三、API 开发规范

### 3.1 API 路由结构

✅ **DO - RESTful 设计**:
```
GET    /api/voices         - 获取列表
POST   /api/voices         - 创建新记录
GET    /api/voices/[id]    - 获取单条记录
PATCH  /api/voices/[id]    - 更新记录
DELETE /api/voices/[id]    - 删除记录

POST   /api/voices/[id]/rate    - 子资源操作
```

❌ **DON'T**:
```
GET    /api/getVoices
POST   /api/createVoice
POST   /api/updateVoice
POST   /api/deleteVoice
```

---

### 3.2 API 实现标准流程

✅ **DO**:
```typescript
export const POST = async (request: Request) => {
    try {
        // 1. 认证检查（最先）
        const session = await getSession();
        if (!session?.user) {
            return unauthorizedResponse();
        }

        // 2. 解析请求数据
        const body = await request.json();

        // 3. 数据验证
        const validated = insertVoiceSchema.parse(body);

        // 4. 权限检查
        if (validated.isPublic && !session.user.isAdmin) {
            return errorResponse("Only admin can create public voices", 403);
        }

        // 5. 业务逻辑
        const db = await getDb();
        const [newVoice] = await db.insert(voicesSchema)
            .values({
                ...validated,
                userId: session.user.id,
            })
            .returning();

        // 6. 返回结果
        return successResponse(newVoice, "Created successfully", 201);

    } catch (error) {
        // 7. 错误处理
        return handleApiError(error);
    }
};
```

**流程顺序**:
1. 认证 → 2. 解析 → 3. 验证 → 4. 权限 → 5. 业务逻辑 → 6. 返回 → 7. 错误处理

---

### 3.3 HTTP 状态码使用

✅ **DO**:
```typescript
// 成功
200 OK           - 查询成功
201 Created      - 创建成功
204 No Content   - 删除成功（无返回内容）

// 客户端错误
400 Bad Request      - 请求数据格式错误
401 Unauthorized     - 未认证
403 Forbidden        - 已认证但无权限
404 Not Found        - 资源不存在
422 Unprocessable    - 验证失败

// 服务器错误
500 Internal Server Error  - 服务器错误
```

❌ **DON'T**:
```typescript
// 所有成功都返回 200
return successResponse(data, "Success", 200);  // 创建也用 200

// 所有错误都返回 500
return errorResponse("Error", 500);  // 验证失败也用 500
```

---

## 四、文件处理

### 4.1 音频数据处理流程

✅ **DO**:
```typescript
// 1. 生成音频
const { audio } = await generateSpeech({...});

// 2. 转换为 Buffer（Next.js 需要）
const audioBuffer = Buffer.from(audio.uint8Array);

// 3. 创建 File 对象（R2 上传需要）
const audioFile = new File([audioBuffer], `tts-${Date.now()}.mp3`, {
    type: "audio/mpeg",
});

// 4. 上传到 R2
const uploadResult = await uploadToR2(audioFile, "tts-outputs");

// 5. 保存 URL 到数据库
await db.insert(outputsSchema).values({
    audioUrl: uploadResult.url,
    ...
});
```

**关键点**:
- `Uint8Array` → `Buffer` → `File`
- 设置正确的 MIME 类型
- 统一的文件命名规范

---

### 4.2 返回文件响应

✅ **DO**:
```typescript
// 方式 1: 直接返回二进制数据（适合小文件）
return new Response(audioBuffer, {
    status: 200,
    headers: {
        "Content-Type": "audio/mpeg",
        "Content-Disposition": `attachment; filename="${filename}"`,
        "Content-Length": audioBuffer.length.toString(),
    },
});

// 方式 2: 返回 URL（推荐）
return successResponse({
    audioUrl: "https://cdn.example.com/audio.mp3"
});
```

**选择标准**:
- 小文件（<1MB）→ 直接返回
- 大文件（>1MB）→ 返回 URL
- 需要 CDN 缓存 → 返回 URL

---

## 五、环境管理

### 5.1 环境变量组织

✅ **DO**:
```bash
# .dev.vars (本地开发)
FAL_KEY=fal-xxx-local
CLOUDFLARE_R2_URL=https://pub-xxx.r2.dev
DATABASE_URL=...

# wrangler.jsonc (配置绑定)
{
  "r2_buckets": [...],
  "d1_databases": [...],
  "ai": {...}
}

# 生产环境使用 secrets
pnpm cf:secret FAL_KEY
```

**分类**:
- 敏感信息 → Secrets (FAL_KEY)
- 公共配置 → 环境变量 (CLOUDFLARE_R2_URL)
- 资源绑定 → wrangler.jsonc

---

### 5.2 本地开发优化

✅ **DO - 使用 Remote Bindings**:
```typescript
// next.config.ts
initOpenNextCloudflareForDev({
    experimental: {
        remoteBindings: true,
    }
});
```

```jsonc
// wrangler.jsonc
{
  "r2_buckets": [{
    "bucket_name": "wild-voice-files",
    "binding": "FILES",
    "experimental_remote": true  // 连接真实 R2
  }]
}
```

**优势**:
- URL 统一（不需要本地/生产切换）
- 数据一致性
- 更接近生产环境

❌ **DON'T**:
```typescript
// 复杂的环境判断逻辑
const isDev = process.env.NODE_ENV === "development";
const url = isDev ? "http://localhost/..." : "https://prod/...";
```

---

## 六、AI SDK 使用

### 6.1 Provider 配置

✅ **DO**:
```typescript
// 在函数内动态创建 provider（获取环境变量）
export const POST = async (request: Request) => {
    const { env } = await getCloudflareContext();

    const fal = createFal({
        apiKey: env.FAL_KEY  // 使用 Cloudflare env
    });

    const { audio } = await generateSpeech({
        model: fal.speech('fal-ai/minimax/speech-02-hd'),
        ...
    });
};
```

❌ **DON'T**:
```typescript
// 在模块顶层创建（无法访问 Cloudflare env）
import { fal } from '@ai-sdk/fal';  // 使用 process.env

export const POST = async (request: Request) => {
    // fal 无法访问 env.FAL_KEY
};
```

---

### 6.2 自定义参数传递

✅ **DO**:
```typescript
const { audio } = await generateSpeech({
    model: fal.speech('fal-ai/minimax/speech-02-hd'),
    text: text,
    providerOptions: {
        fal: {  // 使用 providerOptions 传递特定参数
            voice_setting: {
                voice_id: voiceId,
                speed: 1.2,
                pitch: 0,
                emotion: "happy"
            }
        }
    }
});
```

**优势**:
- 保持 AI SDK 的统一接口
- 可以访问提供商特定功能
- 易于迁移到其他提供商

---

## 七、错误处理

### 7.1 分层错误处理

✅ **DO**:
```typescript
// 1. API 层 - 捕获所有错误
export const POST = async (request: Request) => {
    try {
        // 业务逻辑
    } catch (error) {
        return handleApiError(error);  // 统一处理
    }
};

// 2. 错误处理器 - 分类处理
export default function handleApiError(error: unknown) {
    if (error instanceof z.ZodError) {
        // Zod 验证错误
        return errorResponse(error.issues[0].message, 400);
    }

    if (error instanceof SyntaxError) {
        // JSON 解析错误
        return errorResponse("Invalid JSON format", 400);
    }

    // 未知错误
    console.error("Unexpected error:", error);
    return errorResponse("Internal server error", 500);
}
```

---

### 7.2 用户友好的错误信息

✅ **DO**:
```typescript
// Zod schema 中提供清晰的错误信息
name: z.string().min(1, "声音名称不能为空").max(100, "名称不能超过100个字符"),
rating: z.number().min(0, "评分最低为0").max(5, "评分最高为5"),
```

❌ **DON'T**:
```typescript
// 使用默认错误信息
name: z.string().min(1).max(100),  // 错误: "String must contain at least 1 character(s)"
```

---

## 八、测试与调试

### 8.1 使用 .http 文件测试

✅ **DO**:
```http
@baseUrl = http://localhost:3000
@sessionToken = {{your_token}}

### 测试创建
POST {{baseUrl}}/api/voices
Cookie: better-auth.session_token={{sessionToken}}
Content-Type: application/json

{
  "name": "Test Voice",
  "category": "Test"
}

### 测试查询
GET {{baseUrl}}/api/voices
Cookie: better-auth.session_token={{sessionToken}}
```

**优势**:
- 版本控制（可提交到 git）
- 团队共享
- 快速测试

---

### 8.2 日志记录

✅ **DO**:
```typescript
// 关键步骤添加日志
console.log("Calling FAL TTS with:", { text: text.substring(0, 50), voiceId });

try {
    const { audio } = await generateSpeech({...});
    console.log("Audio generated successfully, size:", audio.uint8Array.length);
} catch (error) {
    console.error("TTS Error:", error);
    throw error;
}
```

**记录内容**:
- 关键参数（脱敏后）
- 成功/失败状态
- 性能指标（可选）

---

## 九、代码风格

### 9.1 命名规范

✅ **DO**:
```typescript
// 文件名: kebab-case
voice.schema.ts
api-response.ts

// 变量/函数: camelCase
const voiceId = 1;
async function getVoices() {}

// 类型/接口: PascalCase
interface ApiResponse {}
type Voice = {...}

// 常量: UPPER_SNAKE_CASE
const MAX_UPLOAD_SIZE = 10 * 1024 * 1024;
```

---

### 9.2 注释规范

✅ **DO**:
```typescript
// 1. 复杂逻辑添加注释
// 根据环境返回不同的 URL
// 本地开发：使用代理 API
// 生产环境：使用 R2 公共 URL
const isDev = process.env.NODE_ENV === "development";

// 2. 重要参数说明
/**
 * 上传文件到 R2
 * @param file - 要上传的文件
 * @param folder - R2 中的文件夹路径
 * @returns 上传结果，包含 URL 和 key
 */
export async function uploadToR2(file: File, folder: string) {}

// 3. TODO 标记
// TODO: 计算实际音频时长
duration: 0,
```

❌ **DON'T**:
```typescript
// 无意义的注释
const name = "voice";  // 定义 name 变量

// 过时的注释
// 使用 FAL API（实际已改用 AI SDK）
const { audio } = await generateSpeech({...});
```

---

## 十、性能优化

### 10.1 数据库查询优化

✅ **DO**:
```typescript
// 1. 只查询需要的字段
const voices = await db.select({
    id: voicesSchema.id,
    name: voicesSchema.name,
    rating: voicesSchema.rating
}).from(voicesSchema);

// 2. 使用 limit 限制结果
.limit(10)

// 3. 添加索引（在 schema 中）
export const voicesSchema = sqliteTable("voices", {
    ...
}, (table) => ({
    userIdIdx: index("user_id_idx").on(table.userId),
}));
```

---

### 10.2 缓存策略

✅ **DO**:
```typescript
// R2 设置长期缓存
httpMetadata: {
    contentType: file.type,
    cacheControl: "public, max-age=31536000",  // 1年
}

// API 响应设置缓存
return new Response(JSON.stringify(data), {
    status: 200,
    headers: {
        "Cache-Control": "public, max-age=300",  // 5分钟
    }
});
```

---

## 十一、安全性

### 11.1 权限检查

✅ **DO**:
```typescript
// 多层权限检查
const [voice] = await db.select().from(voicesSchema).where(...);

// 1. 存在性检查
if (!voice) {
    return notFoundResponse("Voice not found");
}

// 2. 所有权检查
if (!voice.isPublic && voice.userId !== session.user.id) {
    return errorResponse("You don't have access to this voice", 403);
}

// 3. 操作权限检查
if (operation === "delete" && !session.user.isAdmin) {
    return errorResponse("Only admin can delete public voices", 403);
}
```

---

### 11.2 数据清洗

✅ **DO**:
```typescript
// 1. 使用 Zod 验证和转换
const schema = z.object({
    name: z.string().trim().min(1).max(100),  // 自动去除空格
    rating: z.coerce.number().min(0).max(5),  // 强制转换为数字
});

// 2. 过滤不该由用户设置的字段
const { id, createdAt, updatedAt, ...userInput } = validated;

// 3. 使用 .omit() 排除敏感字段
export const updateVoiceSchema = insertVoiceSchema.partial().omit({
    id: true,
    userId: true,
    createdAt: true,
});
```

---

## 📋 检查清单

在完成一个功能时，检查以下项目：

### 数据库
- [ ] Schema 字段类型正确
- [ ] 外键关联设置了 onDelete 行为
- [ ] 时间戳字段使用 defaultNow() 和 $onUpdate()
- [ ] 创建了 Zod 验证 schema
- [ ] 运行并测试了 migration

### API
- [ ] 实现了认证检查
- [ ] 使用了数据验证
- [ ] 权限检查完整
- [ ] 使用统一响应格式
- [ ] 返回正确的状态码
- [ ] 错误处理完善

### 代码质量
- [ ] 命名规范一致
- [ ] 添加了必要注释
- [ ] 没有硬编码的值
- [ ] 类型安全（无 any）
- [ ] 代码格式化

### 测试
- [ ] 创建了 .http 测试用例
- [ ] 测试了成功场景
- [ ] 测试了失败场景
- [ ] 验证了权限控制

---

_生成时间: 2025-10-05_
