# WildVoice 项目自测题库

## 📝 说明
本文档包含选择题、填空题和编程题，帮助你巩固今天学到的知识。

---

## 一、选择题 (单选)

### 1. Drizzle ORM 基础

**Q1.1**: 在 Drizzle ORM 中，如何定义一个自增的主键？
- A. `id: integer("id").primaryKey()`
- B. `id: integer("id").primaryKey({ autoIncrement: true })`
- C. `id: integer("id").autoIncrement().primaryKey()`
- D. `id: integer("id").primary({ increment: true })`

<details>
<summary>查看答案</summary>
答案: B

解释: 在 Drizzle ORM 中，自增主键需要使用 `.primaryKey({ autoIncrement: true })` 配置。
</details>

---

**Q1.2**: 以下哪个字段定义是正确的时间戳字段？
- A. `createdAt: text("created_at").defaultNow()`
- B. `createdAt: integer("created_at").timestamp().defaultNow()`
- C. `createdAt: integer("created_at", { mode: "timestamp" }).defaultNow()`
- D. `createdAt: timestamp("created_at").defaultNow()`

<details>
<summary>查看答案</summary>
答案: C

解释: Drizzle ORM 在 SQLite 中使用 `integer` 存储时间戳，需要指定 `{ mode: "timestamp" }` 并使用 `.defaultNow()` 设置默认值。
</details>

---

**Q1.3**: 如何定义一个外键关联，并在父记录删除时级联删除子记录？
- A. `.references(() => user.id)`
- B. `.references(() => user.id, { onDelete: "cascade" })`
- C. `.foreignKey(() => user.id).cascade()`
- D. `.references(() => user.id).onDelete("cascade")`

<details>
<summary>查看答案</summary>
答案: B

解释: 需要在 `.references()` 的第二个参数中指定 `{ onDelete: "cascade" }`。
</details>

---

### 2. Next.js API Routes

**Q2.1**: 在 Next.js 15 App Router 中，如何创建一个动态 API 路由来处理 `/api/users/[id]`？
- A. 创建 `src/app/api/users/[id].ts`
- B. 创建 `src/app/api/users/[id]/route.ts`
- C. 创建 `src/app/api/users/route.ts` 并处理参数
- D. 创建 `src/app/api/users/:id/route.ts`

<details>
<summary>查看答案</summary>
答案: B

解释: App Router 使用文件夹 `[id]` 表示动态路由，文件名必须是 `route.ts`。
</details>

---

**Q2.2**: 以下哪种方式可以正确返回 JSON 响应？
- A. `return { data: "hello" }`
- B. `return Response.json({ data: "hello" })`
- C. `return new Response(JSON.stringify({ data: "hello" }), { headers: { 'Content-Type': 'application/json' } })`
- D. B 和 C 都正确

<details>
<summary>查看答案</summary>
答案: D

解释: `Response.json()` 是简写，等价于手动设置 Content-Type 的方式。
</details>

---

**Q2.3**: 在 API Route 中如何获取 POST 请求的 body？
- A. `request.body`
- B. `await request.json()`
- C. `request.json()`
- D. `request.data`

<details>
<summary>查看答案</summary>
答案: B

解释: 需要使用 `await request.json()` 异步解析请求体。
</details>

---

### 3. Cloudflare Workers & R2

**Q3.1**: 在 Cloudflare Workers 环境中，如何获取环境变量？
- A. `process.env.FAL_KEY`
- B. `import.meta.env.FAL_KEY`
- C. `const { env } = await getCloudflareContext(); env.FAL_KEY`
- D. `Deno.env.get("FAL_KEY")`

<details>
<summary>查看答案</summary>
答案: C

解释: 在 @opennextjs/cloudflare 中，需要通过 `getCloudflareContext()` 获取环境对象。
</details>

---

**Q3.2**: Remote Bindings 的作用是什么？
- A. 在生产环境使用本地数据库
- B. 在本地开发时连接真实的 Cloudflare 资源
- C. 远程调试代码
- D. 绑定远程 API

<details>
<summary>查看答案</summary>
答案: B

解释: Remote Bindings 允许本地开发时直接连接真实的 D1、R2、KV 等 Cloudflare 资源。
</details>

---

**Q3.3**: 上传文件到 R2 时，httpMetadata 的作用是什么？
- A. 设置文件的 HTTP 请求头
- B. 设置文件的元数据，如 Content-Type 和 Cache-Control
- C. 设置文件的访问权限
- D. 设置文件的加密选项

<details>
<summary>查看答案</summary>
答案: B

解释: httpMetadata 用于设置文件的 Content-Type、Cache-Control 等 HTTP 响应头信息。
</details>

---

### 4. AI SDK

**Q4.1**: 为什么选择使用 AI SDK 而不是直接调用 FAL API？
- A. AI SDK 性能更好
- B. AI SDK 提供统一接口，易于切换提供商
- C. FAL API 不稳定
- D. AI SDK 免费

<details>
<summary>查看答案</summary>
答案: B

解释: AI SDK 的主要优势是提供统一的接口，可以轻松在不同 AI 提供商之间切换。
</details>

---

**Q4.2**: 如何在 AI SDK 中使用 FAL 特定的参数（如 speed, pitch）？
- A. 直接传入参数
- B. 使用 `providerOptions.fal`
- C. 使用 `headers`
- D. 不支持

<details>
<summary>查看答案</summary>
答案: B

解释: 通过 `providerOptions.fal` 可以传递 FAL 特定的参数。
</details>

---

**Q4.3**: `generateSpeech` 返回的 `audio` 对象如何转换为 Buffer？
- A. `Buffer.from(audio)`
- B. `Buffer.from(audio.uint8Array)`
- C. `new Buffer(audio)`
- D. `audio.toBuffer()`

<details>
<summary>查看答案</summary>
答案: B

解释: 需要访问 `audio.uint8Array` 属性，然后使用 `Buffer.from()` 转换。
</details>

---

## 二、填空题

### 1. Drizzle ORM

**Q1**: 在 Drizzle ORM 中，`createInsertSchema` 的作用是__________，`createSelectSchema` 的作用是__________。

<details>
<summary>查看答案</summary>
答案:
- createInsertSchema: 从数据库 schema 自动生成用于插入数据的 Zod 验证 schema
- createSelectSchema: 从数据库 schema 自动生成用于查询数据的 Zod 验证 schema
</details>

---

**Q2**: 要让字段在更新时自动更新时间，应使用 `__________` 方法。

<details>
<summary>查看答案</summary>
答案: `.$onUpdate(() => new Date())`

示例:
```typescript
updatedAt: integer("updated_at", { mode: "timestamp" })
  .$onUpdate(() => new Date())
  .notNull()
```
</details>

---

### 2. API 设计

**Q3**: 创建资源成功应返回 HTTP 状态码 __________，资源未找到应返回 __________，未授权应返回 __________。

<details>
<summary>查看答案</summary>
答案: 201, 404, 401

- 201 Created - 资源创建成功
- 404 Not Found - 资源未找到
- 401 Unauthorized - 未授权
</details>

---

**Q4**: 在 API 中，应该把 __________ 检查放在最前面，然后进行 __________ 验证，最后执行业务逻辑。

<details>
<summary>查看答案</summary>
答案: 认证(authentication)，数据(data validation)

标准流程:
1. 认证检查
2. 权限检查
3. 数据验证
4. 业务逻辑
5. 返回响应
</details>

---

### 3. 文件处理

**Q5**: 要返回音频文件，Response 的 Content-Type 应设置为 __________，如果要让浏览器下载而不是播放，Content-Disposition 应设置为 __________。

<details>
<summary>查看答案</summary>
答案: audio/mpeg (或 audio/wav, audio/ogg 等), attachment; filename="xxx.mp3"

示例:
```typescript
{
  'Content-Type': 'audio/mpeg',
  'Content-Disposition': 'attachment; filename="audio.mp3"'
}
```

如果要在线播放，使用 `inline` 代替 `attachment`。
</details>

---

## 三、编程题

### 题目 1: 创建 Category Schema

**需求**: 为 WildVoice 创建一个 `categories` 表，用于对 voices 进行分类。

**要求**:
1. 字段：id (自增主键), name (分类名), description (描述, 可选), createdAt
2. 创建对应的 Zod validation schemas
3. 导出 TypeScript 类型

**提示**: 参考 voice.schema.ts 的结构

<details>
<summary>查看参考答案</summary>

```typescript
// src/modules/categories/schemas/category.schema.ts
import { integer, sqliteTable, text } from "drizzle-orm/sqlite-core";
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import { z } from "zod";

export const categoriesSchema = sqliteTable("categories", {
    id: integer("id").primaryKey({ autoIncrement: true }),
    name: text("name").notNull(),
    description: text("description"),
    createdAt: integer("created_at", { mode: "timestamp" })
        .defaultNow()
        .notNull(),
});

export const insertCategorySchema = createInsertSchema(categoriesSchema, {
    name: z.string().min(1, "分类名称不能为空").max(50, "名称过长"),
    description: z.string().max(200, "描述过长").optional(),
});

export const selectCategorySchema = createSelectSchema(categoriesSchema);

export type Category = typeof categoriesSchema.$inferSelect;
export type NewCategory = typeof categoriesSchema.$inferInsert;
```
</details>

---

### 题目 2: 实现获取单个 Voice 的 API

**需求**: 实现 `GET /api/voices/[id]` 接口，返回指定 ID 的 voice 信息。

**要求**:
1. 验证用户认证
2. 检查 voice 是否存在
3. 检查权限（只能访问公共 voice 或自己的 voice）
4. 使用统一响应格式

<details>
<summary>查看参考答案</summary>

```typescript
// src/app/api/voices/[id]/route.ts
import { getDb, voicesSchema } from "@/db";
import { eq } from "drizzle-orm";
import { getSession } from "@/modules/auth/utils/auth-utils";
import {
    successResponse,
    unauthorizedResponse,
    notFoundResponse,
    errorResponse,
} from "@/lib/api-response";
import handleApiError from "@/lib/api-error";

export async function GET(
    request: Request,
    { params }: { params: { id: string } }
) {
    try {
        // 1. 认证检查
        const session = await getSession();
        if (!session?.user) {
            return unauthorizedResponse();
        }

        // 2. 获取 voice
        const db = await getDb();
        const voiceId = parseInt(params.id);

        if (isNaN(voiceId)) {
            return errorResponse("Invalid voice ID", 400);
        }

        const [voice] = await db
            .select()
            .from(voicesSchema)
            .where(eq(voicesSchema.id, voiceId))
            .limit(1);

        if (!voice) {
            return notFoundResponse("Voice not found");
        }

        // 3. 权限检查
        if (!voice.isPublic && voice.userId !== session.user.id) {
            return errorResponse("You don't have access to this voice", 403);
        }

        // 4. 返回结果
        return successResponse(voice);
    } catch (error) {
        return handleApiError(error);
    }
}
```
</details>

---

### 题目 3: 实现统计功能

**需求**: 实现一个函数，统计用户生成的 TTS 总数和总时长。

**要求**:
1. 查询 outputs 表
2. 筛选当前用户的 TTS 记录
3. 返回 `{ count: number, totalDuration: number }`

<details>
<summary>查看参考答案</summary>

```typescript
import { getDb, outputsSchema } from "@/db";
import { eq, and, sum, count } from "drizzle-orm";

interface UserStats {
    count: number;
    totalDuration: number;
}

async function getUserTTSStats(userId: string): Promise<UserStats> {
    const db = await getDb();

    const result = await db
        .select({
            count: count(),
            totalDuration: sum(outputsSchema.duration),
        })
        .from(outputsSchema)
        .where(
            and(
                eq(outputsSchema.userId, userId),
                eq(outputsSchema.type, "TTS")
            )
        );

    return {
        count: result[0]?.count || 0,
        totalDuration: result[0]?.totalDuration || 0,
    };
}

// 使用示例
const stats = await getUserTTSStats(session.user.id);
console.log(`生成了 ${stats.count} 个语音，总时长 ${stats.totalDuration} 秒`);
```
</details>

---

## 四、问答题

### Q1: 为什么要使用 Zod 验证而不是直接用 TypeScript？

<details>
<summary>查看参考答案</summary>

**原因**:

1. **运行时验证**: TypeScript 只在编译时检查类型，无法在运行时验证用户输入的数据
2. **数据清洗**: Zod 可以转换和规范化数据（如去除空格、转换类型等）
3. **友好错误**: 提供清晰的验证错误信息，可以直接返回给用户
4. **安全性**: 防止恶意输入和 SQL 注入

**示例**:
```typescript
// TypeScript 无法验证运行时数据
function createVoice(data: { name: string }) {
    // 如果 data.name 是 undefined 或非字符串，TypeScript 无法阻止
}

// Zod 可以在运行时验证
const schema = z.object({ name: z.string().min(1) });
const validated = schema.parse(data); // 会抛出错误如果不符合
```
</details>

---

### Q2: 解释 Remote Bindings 的工作原理和使用场景

<details>
<summary>查看参考答案</summary>

**工作原理**:
- 本地开发时，通过 Wrangler 直接连接到 Cloudflare 的真实资源（D1, R2, KV 等）
- 不使用本地模拟，所有操作直接在云端资源上执行
- 需要在 `wrangler.jsonc` 中添加 `experimental_remote: true`

**使用场景**:
1. **测试真实环境** - 验证代码在实际 Cloudflare 环境中的表现
2. **团队协作** - 多人共享同一数据库，避免数据不同步
3. **避免本地限制** - 本地模拟可能与真实环境有差异

**优势**:
- ✅ URL 统一（不需要本地/生产环境的 URL 切换逻辑）
- ✅ 数据一致性
- ✅ 更接近生产环境

**注意事项**:
- ⚠️ 操作直接影响真实数据
- ⚠️ 需要网络连接
- ⚠️ 建议使用单独的开发环境资源
</details>

---

### Q3: 什么时候应该使用 `.$onUpdate()` 而不是 `.defaultNow()`？

<details>
<summary>查看参考答案</summary>

**区别**:

1. **`.defaultNow()`**
   - 只在**首次插入**时设置值
   - 用于 `createdAt` 字段

2. **`.$onUpdate()`**
   - 在**每次更新**时设置新值
   - 用于 `updatedAt` 字段

**示例**:
```typescript
export const voicesSchema = sqliteTable("voices", {
    id: integer("id").primaryKey({ autoIncrement: true }),

    // 创建时设置，永不改变
    createdAt: integer("created_at", { mode: "timestamp" })
        .defaultNow()
        .notNull(),

    // 创建时设置，每次更新时也更新
    updatedAt: integer("updated_at", { mode: "timestamp" })
        .defaultNow()  // 首次插入的默认值
        .$onUpdate(() => new Date())  // 每次更新时的值
        .notNull(),
});
```

**行为**:
```typescript
// INSERT
const voice = await db.insert(voicesSchema).values({ name: "Test" });
// createdAt: 2025-10-05 10:00:00
// updatedAt: 2025-10-05 10:00:00

// UPDATE (5分钟后)
await db.update(voicesSchema).set({ name: "Updated" }).where(...);
// createdAt: 2025-10-05 10:00:00  (不变)
// updatedAt: 2025-10-05 10:05:00  (更新)
```
</details>

---

## 五、实战挑战题 🚀

### 挑战 1: 实现 Voice 评分功能

**需求**: 允许用户对 voice 进行评分（1-5星），每个用户只能评分一次。

**要求**:
1. 创建 `voice_ratings` 表
2. 实现 `POST /api/voices/[id]/rate` 接口
3. 更新 voice 的平均评分
4. 防止重复评分

**提示**: 需要创建新的 schema 和关联查询

---

### 挑战 2: 实现分页查询

**需求**: 为 `GET /api/voices` 添加分页功能

**要求**:
1. 支持 `page` 和 `limit` 参数
2. 返回总数、当前页、总页数等信息
3. 响应格式：
```json
{
  "success": true,
  "data": {
    "items": [...],
    "pagination": {
      "page": 1,
      "limit": 10,
      "total": 100,
      "totalPages": 10
    }
  }
}
```

---

### 挑战 3: 实现音频时长计算

**需求**: 在保存 TTS 输出时，计算并保存实际的音频时长

**提示**:
- 可能需要使用音频处理库（如 `get-audio-duration`）
- 或从 FAL API 响应中获取时长信息

---

## 📊 自测评分标准

- **选择题**: 每题 5 分，共 60 分
- **填空题**: 每题 8 分，共 40 分
- **编程题**: 每题 20 分，共 60 分
- **问答题**: 每题 15 分，共 45 分
- **挑战题**: 选做，每题 30 分

**总分**: 205 分（不含挑战题）

**等级评定**:
- 优秀: ≥ 180 分
- 良好: ≥ 150 分
- 合格: ≥ 120 分
- 需加强: < 120 分

---

_生成时间: 2025-10-05_
